<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Hand Gesture Recognition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <style>
      body,
      html {
        height: 100%;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(
          to right,
          #ffafbd,
          #ffc3a0
        ); /* Pink gradient */
        font-family: Arial, sans-serif;
      }
      .output_canvas {
        border: 2px solid #000;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      video {
        display: none; /* Keeps video feed invisible but active */
      }
    </style>
  </head>
  <body>
    <video class="input_video" playsinline autoplay muted></video>
    <canvas class="output_canvas"></canvas>
    <script>
      const videoElement = document.querySelector(".input_video");
      const canvasElement = document.querySelector(".output_canvas");
      const canvasCtx = canvasElement.getContext("2d");

      function setupCamera() {
        const constraints = {
          audio: false,
          video: {
            facingMode: "user",
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        };

        navigator.mediaDevices
          .getUserMedia(constraints)
          .then((stream) => {
            videoElement.srcObject = stream;
            initMediaPipe();
          })
          .catch((error) => {
            console.error("Error accessing the camera:", error);
            alert("Error accessing the camera: " + error.message);
          });
      }

      function initMediaPipe() {
        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });

        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({ image: videoElement });
          },
          width: 1280,
          height: 720,
        });
        camera.start();
      }

      function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(
          results.image,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );

        let gesturesDetected = [];
        if (results.multiHandLandmarks) {
          for (const landmarks of results.multiHandLandmarks) {
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
              color: "#00FA9A",
              lineWidth: 5,
            });
            drawLandmarks(canvasCtx, landmarks, {
              color: "#FF6347",
              lineWidth: 2,
            });
          }
        }
        canvasCtx.restore();
      }

      setupCamera();

      function resizeCanvas() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        canvasElement.width = width;
        canvasElement.height = height;
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
    </script>
  </body>
</html>
